"""
GECKO-A Mass Balance Verification Module

This module provides comprehensive mass balance verification for chemical mechanisms
generated by GECKO-A. It validates atom conservation (C, H, N, O, S) across all reactions
and identifies potential errors in the mechanism.

Scientific Background:
- Conservation of mass requires that atoms are neither created nor destroyed in chemical reactions
- For each reaction: sum(atoms in reactants) = sum(atoms in products)
- Small deviations may occur due to:
  - Numerical precision in stoichiometric coefficients
  - Implicit species (O2, N2, H2O) in some reaction schemes
  - Photolysis products that include light energy

References:
- IUPAC Compendium of Chemical Terminology
- Seinfeld & Pandis, "Atmospheric Chemistry and Physics" (2016)

Author: GECKO-A Development Team
"""

import os
import re
import logging
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field
from collections import defaultdict
from pathlib import Path

import numpy as np

logger = logging.getLogger(__name__)


# ==============================================================================
# Physical Constants and Atomic Masses
# ==============================================================================

# Atomic masses (g/mol) - IUPAC 2021 Standard Atomic Weights
ATOMIC_MASSES = {
    'C': 12.0107,
    'H': 1.00794,
    'N': 14.0067,
    'O': 15.9994,
    'S': 32.065,
    'Cl': 35.453,
    'Br': 79.904,
    'F': 18.998,
    'I': 126.904,
}

# Elements to track for mass balance
TRACKED_ELEMENTS = ['C', 'H', 'N', 'O', 'S']

# Inorganic species with known compositions
INORGANIC_COMPOSITIONS = {
    # Radicals and reactive species
    'OH': {'O': 1, 'H': 1},
    'HO': {'O': 1, 'H': 1},
    'HO2': {'H': 1, 'O': 2},
    'O3': {'O': 3},
    'O2': {'O': 2},
    'O': {'O': 1},
    'O1D': {'O': 1},  # Excited oxygen atom
    'O3P': {'O': 1},  # Ground state oxygen atom
    'NO': {'N': 1, 'O': 1},
    'NO2': {'N': 1, 'O': 2},
    'NO3': {'N': 1, 'O': 3},
    'N2O5': {'N': 2, 'O': 5},
    'HNO2': {'H': 1, 'N': 1, 'O': 2},
    'HNO3': {'H': 1, 'N': 1, 'O': 3},
    'HNO4': {'H': 1, 'N': 1, 'O': 4},
    'HONO': {'H': 1, 'O': 2, 'N': 1},
    'HONO2': {'H': 1, 'O': 3, 'N': 1},
    'H2O': {'H': 2, 'O': 1},
    'H2O2': {'H': 2, 'O': 2},
    'H2': {'H': 2},
    'CO': {'C': 1, 'O': 1},
    'CO2': {'C': 1, 'O': 2},
    'SO2': {'S': 1, 'O': 2},
    'SO3': {'S': 1, 'O': 3},
    'H2SO4': {'H': 2, 'S': 1, 'O': 4},
    'SULF': {'H': 2, 'S': 1, 'O': 4},  # Sulfuric acid alias
    'CH4': {'C': 1, 'H': 4},
    'CH2O': {'C': 1, 'H': 2, 'O': 1},
    'HCHO': {'C': 1, 'H': 2, 'O': 1},
    'HCOOH': {'C': 1, 'H': 2, 'O': 2},
    'CH3OH': {'C': 1, 'H': 4, 'O': 1},
    'CH3OOH': {'C': 1, 'H': 4, 'O': 2},
    'CH3ONO2': {'C': 1, 'H': 3, 'N': 1, 'O': 3},
    'N2': {'N': 2},
    'M': {},  # Third body - no atoms
    'HV': {},  # Photon - no atoms
    'DUMMY': {},
    'NOTHING': {},
    'EXTRA': {},
    'FALLOFF': {},
    'TBODY': {},
    'OXYGEN': {'O': 2},
}

# G-prefixed versions of inorganics (gas-phase markers in GECKO)
for code, comp in list(INORGANIC_COMPOSITIONS.items()):
    INORGANIC_COMPOSITIONS[f'G{code}'] = comp


# ==============================================================================
# Data Classes
# ==============================================================================

@dataclass
class Species:
    """Represents a chemical species with its elemental composition."""
    code: str
    formula: str
    n_carbon: int = 0
    n_hydrogen: int = 0
    n_nitrogen: int = 0
    n_oxygen: int = 0
    n_sulfur: int = 0
    molecular_weight: float = 0.0
    is_radical: bool = False
    phase: str = 'G'  # G=gas, A=aerosol, P=particle

    @property
    def composition(self) -> Dict[str, int]:
        """Return elemental composition as dictionary."""
        return {
            'C': self.n_carbon,
            'H': self.n_hydrogen,
            'N': self.n_nitrogen,
            'O': self.n_oxygen,
            'S': self.n_sulfur,
        }

    def calculate_mw(self) -> float:
        """Calculate molecular weight from composition."""
        mw = (self.n_carbon * ATOMIC_MASSES['C'] +
              self.n_hydrogen * ATOMIC_MASSES['H'] +
              self.n_nitrogen * ATOMIC_MASSES['N'] +
              self.n_oxygen * ATOMIC_MASSES['O'] +
              self.n_sulfur * ATOMIC_MASSES['S'])
        return mw


@dataclass
class ReactionSpecies:
    """Represents a species in a reaction with its stoichiometric coefficient."""
    code: str
    coefficient: float = 1.0

    def __repr__(self):
        if self.coefficient == 1.0:
            return self.code
        return f"{self.coefficient:.3f} {self.code}"


@dataclass
class Reaction:
    """Represents a chemical reaction."""
    index: int
    reactants: List[ReactionSpecies]
    products: List[ReactionSpecies]
    rate_expression: str = ""
    reaction_type: str = "unknown"  # thermal, photolysis, etc.
    raw_text: str = ""

    def __repr__(self):
        lhs = " + ".join(str(r) for r in self.reactants)
        rhs = " + ".join(str(p) for p in self.products)
        return f"R{self.index}: {lhs} → {rhs}"


@dataclass
class MassBalanceResult:
    """Result of mass balance check for a single reaction."""
    reaction_index: int
    reaction_text: str
    is_balanced: bool
    element_differences: Dict[str, float]
    reactant_atoms: Dict[str, float]
    product_atoms: Dict[str, float]
    relative_error: float
    absolute_error: float
    warning_level: str  # 'ok', 'minor', 'major', 'critical'
    notes: List[str] = field(default_factory=list)


@dataclass
class MechanismMassBalanceReport:
    """Complete mass balance report for a mechanism."""
    mechanism_name: str
    total_reactions: int
    balanced_reactions: int
    unbalanced_reactions: int
    critical_errors: int
    major_errors: int
    minor_errors: int
    element_totals: Dict[str, Dict[str, float]]  # element -> {consumed, produced}
    unbalanced_details: List[MassBalanceResult]
    overall_balance: Dict[str, float]  # element -> net difference
    is_valid: bool
    summary: str
    recommendations: List[str]


# ==============================================================================
# Dictionary Parser
# ==============================================================================

class DictionaryParser:
    """Parses GECKO-A dictionary.out file to get species compositions."""

    def __init__(self, dictionary_path: str):
        self.dictionary_path = dictionary_path
        self.species: Dict[str, Species] = {}
        self._parse()

    def _parse(self):
        """Parse the dictionary file."""
        if not os.path.exists(self.dictionary_path):
            logger.warning(f"Dictionary file not found: {self.dictionary_path}")
            return

        with open(self.dictionary_path, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line or line.startswith('!') or 'number of record' in line.lower():
                    continue

                try:
                    species = self._parse_line(line)
                    if species:
                        self.species[species.code] = species
                        # Also store with G prefix for gas phase
                        if not species.code.startswith('G'):
                            self.species[f'G{species.code}'] = species
                except Exception as e:
                    logger.debug(f"Failed to parse dictionary line {line_num}: {e}")

        logger.info(f"Parsed {len(self.species)} species from dictionary")

    def _parse_line(self, line: str) -> Optional[Species]:
        """Parse a single dictionary line."""
        parts = self._smart_split(line)
        if len(parts) < 4:
            return None

        code = parts[0]
        formula = parts[1]

        # Find molecular weight (first reasonable float > 10)
        mw = 0.0
        mw_idx = -1
        for idx, p in enumerate(parts[2:], start=2):
            try:
                val = float(p)
                if val >= 10.0 and val < 10000.0:
                    mw = val
                    mw_idx = idx
                    break
            except ValueError:
                continue

        # Extract element counts
        n_c, n_h, n_n, n_o, n_s = 0, 0, 0, 0, 0
        is_radical = False
        phase = 'G'

        if mw_idx >= 0:
            elem_start = mw_idx + 1

            # Skip phase flag if present
            if elem_start < len(parts) and parts[elem_start] in ('G', 'P', 'A'):
                phase = parts[elem_start]
                elem_start += 1

            # Skip radical/generation flag (0 or 1)
            if elem_start < len(parts):
                try:
                    flag = int(parts[elem_start])
                    if flag in (0, 1):
                        is_radical = (flag == 1)
                        elem_start += 1
                except ValueError:
                    pass

            # Extract element counts
            elem_values = []
            for p in parts[elem_start:elem_start + 6]:
                try:
                    elem_values.append(int(float(p)))
                except ValueError:
                    break

            if len(elem_values) >= 1:
                n_c = elem_values[0]
            if len(elem_values) >= 2:
                n_h = elem_values[1]
            if len(elem_values) >= 3:
                n_n = elem_values[2]
            if len(elem_values) >= 4:
                n_o = elem_values[3]
            if len(elem_values) >= 5:
                n_s = elem_values[4]

        return Species(
            code=code,
            formula=formula,
            n_carbon=n_c,
            n_hydrogen=n_h,
            n_nitrogen=n_n,
            n_oxygen=n_o,
            n_sulfur=n_s,
            molecular_weight=mw,
            is_radical=is_radical,
            phase=phase
        )

    def _smart_split(self, text: str) -> List[str]:
        """Smart split handling Fortran merged numbers."""
        parts = text.split()
        result = []

        # Pattern to detect merged scientific notation
        sci_pattern = re.compile(r'([+-]?\d+\.?\d*[EeDd][+-]?\d{1,2})(\d)')

        for part in parts:
            # Check for merged scientific notation
            match = sci_pattern.search(part)
            if match:
                # Split merged numbers
                first = match.group(1)
                rest = part[match.end()-1:]
                result.append(first)
                if rest:
                    result.extend(self._smart_split(rest))
            else:
                result.append(part)

        return result

    def get_composition(self, code: str) -> Dict[str, int]:
        """Get elemental composition for a species code."""
        # Check known inorganics first
        code_upper = code.upper()
        if code_upper in INORGANIC_COMPOSITIONS:
            return INORGANIC_COMPOSITIONS[code_upper]

        # Strip G prefix
        code_base = code[1:] if code.startswith('G') else code
        code_base_upper = code_base.upper()

        if code_base_upper in INORGANIC_COMPOSITIONS:
            return INORGANIC_COMPOSITIONS[code_base_upper]

        # Check dictionary
        species = self.species.get(code) or self.species.get(code_base)
        if species:
            return species.composition

        # Unknown species
        return {}


# ==============================================================================
# Reaction Parser
# ==============================================================================

class ReactionParser:
    """Parses GECKO-A mechanism files."""

    # Reaction arrow patterns
    ARROW_PATTERNS = ['=>', '->', '=', '→']

    def __init__(self, mechanism_path: str):
        self.mechanism_path = mechanism_path
        self.reactions: List[Reaction] = []
        self._parse()

    def _parse(self):
        """Parse the mechanism file."""
        if not os.path.exists(self.mechanism_path):
            logger.warning(f"Mechanism file not found: {self.mechanism_path}")
            return

        with open(self.mechanism_path, 'r') as f:
            lines = f.readlines()

        reaction_idx = 0
        for line in lines:
            # Skip comments and empty lines
            clean_line = line.split('!')[0].strip()
            if not clean_line:
                continue

            reaction = self._parse_reaction(clean_line, reaction_idx)
            if reaction:
                self.reactions.append(reaction)
                reaction_idx += 1

        logger.info(f"Parsed {len(self.reactions)} reactions from mechanism")

    def _parse_reaction(self, line: str, index: int) -> Optional[Reaction]:
        """Parse a single reaction line."""
        # Find arrow separator
        arrow = None
        arrow_pos = -1

        for pattern in self.ARROW_PATTERNS:
            pos = line.find(pattern)
            if pos > 0:
                arrow = pattern
                arrow_pos = pos
                break

        if arrow is None:
            return None

        lhs = line[:arrow_pos].strip()
        rhs = line[arrow_pos + len(arrow):].strip()

        # Extract rate expression if present (usually at end)
        rate_expr = ""
        rate_match = re.search(r'(\d+\.\d*[Ee][+-]?\d+.*?)$', rhs)
        if rate_match:
            rate_expr = rate_match.group(1)
            rhs = rhs[:rate_match.start()].strip()

        # Parse reactants and products
        reactants = self._parse_species_side(lhs)
        products = self._parse_species_side(rhs)

        if not reactants and not products:
            return None

        # Determine reaction type
        reaction_type = "thermal"
        if "HV" in lhs or "hv" in lhs.lower():
            reaction_type = "photolysis"
        elif "M" in lhs or "FALLOFF" in lhs:
            reaction_type = "pressure-dependent"

        return Reaction(
            index=index,
            reactants=reactants,
            products=products,
            rate_expression=rate_expr,
            reaction_type=reaction_type,
            raw_text=line
        )

    def _parse_species_side(self, side: str) -> List[ReactionSpecies]:
        """Parse one side of a reaction (reactants or products)."""
        species_list = []

        # Split by + but handle parentheses
        tokens = self._split_by_plus(side)

        for token in tokens:
            token = token.strip()
            if not token:
                continue

            # Parse coefficient and species name
            coeff = 1.0
            name = token

            # Check for leading coefficient (e.g., "2 NO2" or "0.5 HCHO")
            match = re.match(r'^([\d.]+)\s*[*]?\s*(.+)$', token)
            if match:
                try:
                    coeff = float(match.group(1))
                    name = match.group(2)
                except ValueError:
                    pass

            # Clean up name
            name = name.split()[0] if name.split() else name
            name = name.strip()

            # Skip non-species tokens
            non_species = {'HV', 'hv', 'M', 'FALLOFF', 'EXTRA', 'NOTHING',
                          'DUMMY', 'TBODY', 'OXYGEN', ''}
            if name.upper() in non_species:
                continue

            # Skip if no letters (just numbers)
            if not re.search(r'[a-zA-Z]', name):
                continue

            species_list.append(ReactionSpecies(code=name, coefficient=coeff))

        return species_list

    def _split_by_plus(self, text: str) -> List[str]:
        """Split by + while respecting parentheses."""
        result = []
        current = ""
        paren_depth = 0

        for char in text:
            if char == '(':
                paren_depth += 1
                current += char
            elif char == ')':
                paren_depth -= 1
                current += char
            elif char == '+' and paren_depth == 0:
                result.append(current.strip())
                current = ""
            else:
                current += char

        if current.strip():
            result.append(current.strip())

        return result


# ==============================================================================
# Mass Balance Checker
# ==============================================================================

class MassBalanceChecker:
    """
    Verifies mass balance across chemical reactions.

    For each reaction, checks that:
    sum(coeff_i * atoms_i) for reactants = sum(coeff_j * atoms_j) for products

    for each element (C, H, N, O, S).
    """

    # Tolerance thresholds
    ABSOLUTE_TOLERANCE = 0.01  # Absolute atom difference tolerance
    RELATIVE_TOLERANCE = 0.01  # 1% relative tolerance

    # Warning level thresholds (relative error)
    MINOR_THRESHOLD = 0.05   # 5%
    MAJOR_THRESHOLD = 0.10   # 10%
    CRITICAL_THRESHOLD = 0.20  # 20%

    def __init__(self, dictionary_parser: DictionaryParser):
        self.dict_parser = dictionary_parser
        self._unknown_species: Set[str] = set()

    def check_reaction(self, reaction: Reaction) -> MassBalanceResult:
        """Check mass balance for a single reaction."""
        # Calculate atom counts for reactants
        reactant_atoms = defaultdict(float)
        for rs in reaction.reactants:
            comp = self.dict_parser.get_composition(rs.code)
            if not comp:
                self._unknown_species.add(rs.code)
            for elem, count in comp.items():
                reactant_atoms[elem] += rs.coefficient * count

        # Calculate atom counts for products
        product_atoms = defaultdict(float)
        for ps in reaction.products:
            comp = self.dict_parser.get_composition(ps.code)
            if not comp:
                self._unknown_species.add(ps.code)
            for elem, count in comp.items():
                product_atoms[elem] += ps.coefficient * count

        # Calculate differences
        element_diff = {}
        for elem in TRACKED_ELEMENTS:
            r_count = reactant_atoms.get(elem, 0)
            p_count = product_atoms.get(elem, 0)
            element_diff[elem] = p_count - r_count

        # Calculate total error metrics
        total_reactant_atoms = sum(reactant_atoms.values())
        total_product_atoms = sum(product_atoms.values())

        absolute_error = abs(sum(element_diff.values()))
        relative_error = 0.0
        if total_reactant_atoms > 0:
            relative_error = absolute_error / total_reactant_atoms

        # Determine balance status
        is_balanced = True
        for elem, diff in element_diff.items():
            ref_count = max(reactant_atoms.get(elem, 0), product_atoms.get(elem, 0))
            if ref_count > 0:
                if abs(diff) > self.ABSOLUTE_TOLERANCE:
                    elem_rel_error = abs(diff) / ref_count
                    if elem_rel_error > self.RELATIVE_TOLERANCE:
                        is_balanced = False
                        break

        # Determine warning level
        warning_level = 'ok'
        if not is_balanced:
            if relative_error >= self.CRITICAL_THRESHOLD:
                warning_level = 'critical'
            elif relative_error >= self.MAJOR_THRESHOLD:
                warning_level = 'major'
            elif relative_error >= self.MINOR_THRESHOLD:
                warning_level = 'minor'
            else:
                warning_level = 'minor'

        # Generate notes
        notes = []
        if not is_balanced:
            for elem, diff in element_diff.items():
                if abs(diff) > self.ABSOLUTE_TOLERANCE:
                    if diff > 0:
                        notes.append(f"{elem}: +{diff:.2f} atoms (excess in products)")
                    else:
                        notes.append(f"{elem}: {diff:.2f} atoms (deficit in products)")

        # Check for unknown species
        unknown_in_rxn = []
        for rs in reaction.reactants:
            if rs.code in self._unknown_species:
                unknown_in_rxn.append(rs.code)
        for ps in reaction.products:
            if ps.code in self._unknown_species:
                unknown_in_rxn.append(ps.code)

        if unknown_in_rxn:
            notes.append(f"Unknown species: {', '.join(set(unknown_in_rxn))}")

        return MassBalanceResult(
            reaction_index=reaction.index,
            reaction_text=str(reaction),
            is_balanced=is_balanced,
            element_differences=dict(element_diff),
            reactant_atoms=dict(reactant_atoms),
            product_atoms=dict(product_atoms),
            relative_error=relative_error,
            absolute_error=absolute_error,
            warning_level=warning_level,
            notes=notes
        )

    def check_mechanism(self, reactions: List[Reaction],
                       mechanism_name: str = "GECKO-A Mechanism") -> MechanismMassBalanceReport:
        """Check mass balance for all reactions in a mechanism."""
        results = []
        unbalanced = []

        element_consumed = defaultdict(float)
        element_produced = defaultdict(float)

        critical_count = 0
        major_count = 0
        minor_count = 0

        for reaction in reactions:
            result = self.check_reaction(reaction)
            results.append(result)

            if not result.is_balanced:
                unbalanced.append(result)

                if result.warning_level == 'critical':
                    critical_count += 1
                elif result.warning_level == 'major':
                    major_count += 1
                else:
                    minor_count += 1

            # Accumulate element totals
            for elem in TRACKED_ELEMENTS:
                element_consumed[elem] += result.reactant_atoms.get(elem, 0)
                element_produced[elem] += result.product_atoms.get(elem, 0)

        # Calculate overall balance
        overall_balance = {}
        for elem in TRACKED_ELEMENTS:
            overall_balance[elem] = element_produced[elem] - element_consumed[elem]

        # Element totals
        element_totals = {}
        for elem in TRACKED_ELEMENTS:
            element_totals[elem] = {
                'consumed': element_consumed[elem],
                'produced': element_produced[elem],
                'difference': overall_balance[elem]
            }

        # Determine validity
        is_valid = critical_count == 0

        # Generate summary
        total = len(reactions)
        balanced = total - len(unbalanced)

        summary_lines = [
            f"Mass Balance Report for {mechanism_name}",
            f"=" * 50,
            f"Total reactions analyzed: {total}",
            f"Balanced reactions: {balanced} ({100*balanced/total:.1f}%)" if total > 0 else "No reactions",
            f"Unbalanced reactions: {len(unbalanced)}",
            f"  - Critical errors: {critical_count}",
            f"  - Major errors: {major_count}",
            f"  - Minor errors: {minor_count}",
            "",
            "Element Balance Summary:",
        ]

        for elem in TRACKED_ELEMENTS:
            diff = overall_balance[elem]
            if abs(diff) > 0.1:
                status = "⚠️ IMBALANCED" if abs(diff) > 10 else "⚡ Minor deviation"
            else:
                status = "✓ Balanced"
            summary_lines.append(f"  {elem}: {status} (net: {diff:+.2f} atoms)")

        # Generate recommendations
        recommendations = []

        if critical_count > 0:
            recommendations.append(
                f"CRITICAL: {critical_count} reactions have severe mass balance errors. "
                "Review these reactions for missing products or incorrect stoichiometry."
            )

        if len(self._unknown_species) > 0:
            recommendations.append(
                f"WARNING: {len(self._unknown_species)} species have unknown compositions. "
                "Consider adding these to the dictionary: " +
                ", ".join(sorted(self._unknown_species)[:10]) +
                ("..." if len(self._unknown_species) > 10 else "")
            )

        if abs(overall_balance.get('C', 0)) > 10:
            recommendations.append(
                "Carbon balance issue: Consider checking fragmentation reactions "
                "and ensuring all C-containing products are accounted for."
            )

        if abs(overall_balance.get('N', 0)) > 5:
            recommendations.append(
                "Nitrogen balance issue: Verify NOx cycling and organic nitrate formation."
            )

        if not recommendations:
            recommendations.append("Mechanism passes mass balance verification.")

        return MechanismMassBalanceReport(
            mechanism_name=mechanism_name,
            total_reactions=total,
            balanced_reactions=balanced,
            unbalanced_reactions=len(unbalanced),
            critical_errors=critical_count,
            major_errors=major_count,
            minor_errors=minor_count,
            element_totals=element_totals,
            unbalanced_details=unbalanced,
            overall_balance=overall_balance,
            is_valid=is_valid,
            summary="\n".join(summary_lines),
            recommendations=recommendations
        )

    @property
    def unknown_species(self) -> Set[str]:
        """Return set of species with unknown compositions."""
        return self._unknown_species.copy()


# ==============================================================================
# Carbon Number Tracker
# ==============================================================================

class CarbonTracker:
    """
    Tracks carbon number distribution through the mechanism.

    This helps verify that carbon fragmentation and oligomerization
    reactions are properly balanced.
    """

    def __init__(self, dictionary_parser: DictionaryParser):
        self.dict_parser = dictionary_parser

    def track_carbon_flow(self, reactions: List[Reaction]) -> Dict[str, Any]:
        """
        Track carbon number changes through reactions.

        Returns:
            Dictionary with carbon flow analysis
        """
        # Track reactions that change carbon number
        fragmenting = []  # Products have less C than reactants
        oligomerizing = []  # Products have more C than reactants
        conserving = []  # Carbon number conserved

        # Carbon distribution
        reactant_c_dist = defaultdict(int)
        product_c_dist = defaultdict(int)

        for rxn in reactions:
            # Calculate total carbon in reactants and products
            reactant_c = 0
            max_reactant_c = 0
            for rs in rxn.reactants:
                comp = self.dict_parser.get_composition(rs.code)
                c_count = comp.get('C', 0)
                reactant_c += rs.coefficient * c_count
                max_reactant_c = max(max_reactant_c, c_count)
                if c_count > 0:
                    reactant_c_dist[c_count] += 1

            product_c = 0
            max_product_c = 0
            for ps in rxn.products:
                comp = self.dict_parser.get_composition(ps.code)
                c_count = comp.get('C', 0)
                product_c += ps.coefficient * c_count
                max_product_c = max(max_product_c, c_count)
                if c_count > 0:
                    product_c_dist[c_count] += 1

            # Classify reaction
            c_diff = product_c - reactant_c

            if abs(c_diff) < 0.1:
                conserving.append(rxn)
            elif c_diff < 0:
                fragmenting.append({
                    'reaction': rxn,
                    'c_lost': -c_diff,
                    'max_reactant_c': max_reactant_c,
                    'max_product_c': max_product_c
                })
            else:
                oligomerizing.append({
                    'reaction': rxn,
                    'c_gained': c_diff,
                    'max_reactant_c': max_reactant_c,
                    'max_product_c': max_product_c
                })

        return {
            'fragmenting_reactions': len(fragmenting),
            'oligomerizing_reactions': len(oligomerizing),
            'conserving_reactions': len(conserving),
            'fragmenting_details': fragmenting[:20],  # Top 20
            'oligomerizing_details': oligomerizing[:20],
            'reactant_c_distribution': dict(reactant_c_dist),
            'product_c_distribution': dict(product_c_dist),
        }


# ==============================================================================
# Main Verification Function
# ==============================================================================

def verify_mass_balance(output_dir: str,
                       voc_name: str = "Unknown",
                       verbose: bool = False) -> MechanismMassBalanceReport:
    """
    Main function to verify mass balance for a GECKO-A mechanism.

    Args:
        output_dir: Directory containing GECKO-A output files
        voc_name: Name of the VOC for report identification
        verbose: If True, print detailed output

    Returns:
        MechanismMassBalanceReport with complete analysis
    """
    # Find files
    dict_path = os.path.join(output_dir, "dictionary.out")

    # Find mechanism file
    mech_path = os.path.join(output_dir, "reactions.txt")
    if not os.path.exists(mech_path):
        import glob
        mec_files = glob.glob(os.path.join(output_dir, "*.mec"))
        if mec_files:
            mech_path = mec_files[0]
        else:
            # Try reactions.dat
            mech_path = os.path.join(output_dir, "reactions.dat")

    # Parse dictionary
    dict_parser = DictionaryParser(dict_path)

    # Parse reactions
    rxn_parser = ReactionParser(mech_path)

    # Check mass balance
    checker = MassBalanceChecker(dict_parser)
    report = checker.check_mechanism(rxn_parser.reactions, f"{voc_name} Mechanism")

    if verbose:
        print(report.summary)
        print("\nRecommendations:")
        for rec in report.recommendations:
            print(f"  • {rec}")

        if report.unbalanced_details:
            print(f"\nTop Unbalanced Reactions (showing first 10):")
            for result in report.unbalanced_details[:10]:
                print(f"\n  {result.reaction_text}")
                print(f"    Warning: {result.warning_level.upper()}")
                for note in result.notes:
                    print(f"    - {note}")

    return report


def generate_mass_balance_json(report: MechanismMassBalanceReport) -> Dict[str, Any]:
    """
    Convert mass balance report to JSON-serializable dictionary.

    Args:
        report: MechanismMassBalanceReport object

    Returns:
        JSON-serializable dictionary
    """
    return {
        'mechanism_name': report.mechanism_name,
        'summary': {
            'total_reactions': report.total_reactions,
            'balanced_reactions': report.balanced_reactions,
            'unbalanced_reactions': report.unbalanced_reactions,
            'balance_percentage': (report.balanced_reactions / report.total_reactions * 100
                                   if report.total_reactions > 0 else 0),
            'is_valid': report.is_valid,
        },
        'errors': {
            'critical': report.critical_errors,
            'major': report.major_errors,
            'minor': report.minor_errors,
        },
        'element_balance': {
            elem: {
                'consumed': data['consumed'],
                'produced': data['produced'],
                'net_difference': data['difference'],
                'is_balanced': abs(data['difference']) < 1.0,
            }
            for elem, data in report.element_totals.items()
        },
        'overall_balance': report.overall_balance,
        'unbalanced_reactions': [
            {
                'index': r.reaction_index,
                'reaction': r.reaction_text,
                'warning_level': r.warning_level,
                'relative_error': r.relative_error,
                'element_differences': r.element_differences,
                'notes': r.notes,
            }
            for r in report.unbalanced_details[:50]  # Limit to 50
        ],
        'recommendations': report.recommendations,
        'text_summary': report.summary,
    }


def save_mass_balance_report(report: MechanismMassBalanceReport,
                            output_path: str,
                            format: str = 'json') -> str:
    """
    Save mass balance report to file.

    Args:
        report: MechanismMassBalanceReport object
        output_path: Path to save report
        format: 'json' or 'txt'

    Returns:
        Path to saved file
    """
    import json

    if format == 'json':
        with open(output_path, 'w') as f:
            json.dump(generate_mass_balance_json(report), f, indent=2)
    else:
        with open(output_path, 'w') as f:
            f.write(report.summary)
            f.write("\n\n")
            f.write("RECOMMENDATIONS\n")
            f.write("=" * 50 + "\n")
            for rec in report.recommendations:
                f.write(f"• {rec}\n")

            if report.unbalanced_details:
                f.write("\n\nUNBALANCED REACTIONS\n")
                f.write("=" * 50 + "\n")
                for result in report.unbalanced_details:
                    f.write(f"\n{result.reaction_text}\n")
                    f.write(f"  Level: {result.warning_level.upper()}\n")
                    f.write(f"  Relative Error: {result.relative_error:.2%}\n")
                    for note in result.notes:
                        f.write(f"  - {note}\n")

    logger.info(f"Mass balance report saved to {output_path}")
    return output_path


# ==============================================================================
# CLI Entry Point
# ==============================================================================

if __name__ == "__main__":
    import sys
    import argparse

    parser = argparse.ArgumentParser(description='Verify mass balance for GECKO-A mechanisms')
    parser.add_argument('output_dir', help='Directory containing GECKO-A output files')
    parser.add_argument('--voc', default='Unknown', help='VOC name for report')
    parser.add_argument('--output', '-o', help='Output file path')
    parser.add_argument('--format', choices=['json', 'txt'], default='json', help='Output format')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')

    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    report = verify_mass_balance(args.output_dir, args.voc, verbose=args.verbose)

    if args.output:
        save_mass_balance_report(report, args.output, args.format)
    else:
        print(report.summary)
        print("\nRecommendations:")
        for rec in report.recommendations:
            print(f"  • {rec}")
